Automated Model Generation for Library Code
===========================================

Project description
-------------------

The JPF model checker relies on so-called model classes in order to combat 
the notorious state space explosion problem. The burden of writing model class
is almost entirely on the developer. To help the developer in this error prone 
and tedious task, a tool, called model-generator, has already been developed. 
However this tool generates only empty stubs, forcing the developer to add 
the desired behaviour manually.

This project aims to provide a tool to generate model classes for the 
use with model checkers suchas JPF. The generated model classes should 
exhibit behaviour that affects only some relevant state the user is 
interested in.

### Problem definition ###

First of all let's define what we intend for the _state_ of a class.

> The _state_ of a class is the set of fields of that class. We distinguish
> between the state of the class, made up by static fields, and the state of its
> instances, composed by instance fields.

In the context of model checking, having a class with a state composed by many
fields can be a problem, since the global state space may explode. Moreover, one
usually is not interested in _all_ the state of a class.

Hence the code generated by the tool should not include code that modify some
state that is not _relevant_.

> We say that an instruction modifies some relevant state if  a field which is
> part of this state is the
> left hand side operator in an assignment operation, if is and object
> used as a parameter in a method call that may modify it or if it is an object
> on which a method is called.

For instance, suppose that the relevant state is an integer field called `foo`. 
The following code modifies it

    foo = 1;

If `foo` is an instance of some object, then the following method call

    bar(foo);

may modify it, since in method `bar` some methods of `foo` that modify its state
can be called.

Finally we could have the following situation: the object `foo` has a method
`baz` that may potentially modify its state once invoked. The statement

    foo.bar()

should be considered a statement that may modify the state.

The problem that the tool should solve hence is the following: given the code of
the original version of a method and stated the relevant state, generate the 
model for the method with code that affects only the relevant state.


### Proposed solution ###

The problem lends itself to be solved using static analysis techniques. A 
type of static analysis commonly performed on bytecode is side-effect analysis.
In this technique the code is analyzed looking for the memory locations that can
be written (or read) by each instruction. Hence, given a method, one could look
for the state of the class that it modifies.

The problem stated in the previous section looks like a side-effect analysis
reversed: given the relevant state, find the code that affects it.

A promising technique to tackle this problem is _slicing_. Basically, slicing
takes a program point and a slicing criterion and prunes the Control Flow Graph
(CFG) to include only the nodes consistent with the given criterion.

Defined in this way, slicing is not enough for our task, because we need to deal
with data dependencies too, not only control dependencies. Here comes to help
the Program Dependence Graph, introduced in [Fe87].

The Program Dependence Graph (PDG) is a graph whose nodes are instructions and
the edges express dependencies between instructions. Dependencies can be of two
types:

 * Control dependencies: a control dependency exists between a statement `S2`
   and the predicate `S1` that controls its execution

        if (A) then    // S1
          B = C * D    // S2

 * Data dependencies: a data dependency exists between two statements `S1` and
   `S2` if a variable appearing in one statement can have an incorrect value if
   the order of the two statements is reversed

        A = B * C      // S1
        D = A * E      // S2

With a graph like this representing relations between statements in the code, we
can first find the nodes that affect directly the relevant state. Then we can
keep all the nodes they depend on and discard all the others. This way we will
have a model method that contains code that only affects the relevant state.


### Implementation ###

The [SOOT](http://www.sable.mcgill.ca/soot/) framework is a good candidate to
perform static analysis of Java programs. It has a lot of features, is actively
developed and has an active mailing list. It already includes a class to build a
PDG from a piece of code, however this class does not seem to fit our purposes.

SOOT does not include slicing facilities. The 
[Indus](http://indus.projects.cis.ksu.edu/) project builds on top of SOOT,
adding, among other things, the capability of slicing a control flow graph.
However this project seems to be not actively developed since 2007. It is based 
on an old version of SOOT (2.1, the current is 2.5), so a partial rewrite of the
code may be necessary to use this tool. In any case this can be a good starting
point.

Finally the [OCSEGen](https://code.google.com/p/envgen/) project provides tools
to generate environments for model checking. An integration of this new tool
with this project seems interesting, since we can leverage existing and already
tested code.

Hence I plan to implement the tool with a modular architecture, in order to make
possible to plug in different model generation strategies. I plan to make this
tool both as standalone and as an extension of OcseGEN.


###Â Examples ###

In all these examples we are going to use Java code and the Jimple
representation given by SOOT.

#### A simple example ####

Suppose that we have a class `Point` that represents a point in the 2D space

```java
package examples;

public class Point {
  private double x, y;

  public Point(double x, double y) {
    this.x = x;
    this.y = y;
  }

  /**
   * This method translates the point.
   */
  public void translate(double newX, double newY) {
    x = newX;
    y = newY;
  }
}
```

We want to model the method `translate`.
The state of this class is composed by the two fields `x` and `y`. Suppose that
the relevant state is only `x`. Hence the tool should generate the following
code for the model version of the class

```java
public void translate(double newX, double newY) {
  x = newX;
}
```

Let's take a look at the Jimple representation of the code of this method

    public void translate(double, double)
    {
        examples.Point r0;
        double d0, d1;

        r0 := @this: examples.Point;
        d0 := @parameter0: double;
        d1 := @parameter1: double;
        r0.<examples.Point: double x> = d0;
        r0.<examples.Point: double y> = d1;
        return;
    }

We can then build the PDG, that looks like the following figure
The cyan node is the one that affects the relevant state, whereas pale green
ones are the ones on which it depends on (apart from `return`, that should be
generated anyway).

![Point PFG](https://raw.github.com/Cecca/jpf-proposal/master/Point.png)

We can then prune the graph from non necessary nodes, getting the following
Jimple representation, that corresponds to the code presented earlier for the
model of the method.

    public void translate(double, double)
    {
        examples.Point r0;
        double d0, d1;

        r0 := @this: examples.Point;
        d0 := @parameter0: double;
        d1 := @parameter1: double;
        r0.<examples.Point: double x> = d0;
        return;
    }


#### A slightly more complex example ####

In this example we will revisit a classic used in introductory Object Oriented
Programming courses: the `BankAccount` class. This class has two fields: `name`,
that represents the name of the account holder, and `amount`, that represents the
amount of money in the account. We will see only the method `deposit(double)`,
that adds the specified amount of money to the account. However, the bank using
this software has a special treatment for customers with a deposit of more than
`100000$`: they are _star_ customers, hence their name is followed by a `*`.

This is the code of the class (the code below won't behave correctly for
customers that are already _stars_, since it will append a `*` at each
deposit operation, however this is only for illustrative purposes).

```java
package examples;

public class BankAccount {
  private String name;
  private double amount;

  public void deposit(double quantity) {
    if (quantity > 0) {
      amount += quantity;
      if(amount > 100000) {
        name += "*";
      }
    }
  }
}
```

In the context of model checking, the user may not be interested in tracking the
changes of the name of customers when they become star ones. Hence the relevant
state of this class is only the `amount` field.

The Jimple representation of the bytecode is the following

    public void deposit(double)
    {
        examples.BankAccount r0;
        double d0, $d1, $d2, $d3;
        byte $b0, $b1;
        java.lang.StringBuilder $r3, $r6;
        java.lang.String $r4, $r5, $r7;

        r0 := @this: examples.BankAccount;
        d0 := @parameter0: double;
        $b0 = d0 cmpl 0.0;
        if $b0 <= 0 goto label0;

        $d1 = r0.<examples.BankAccount: double amount>;
        $d2 = $d1 + d0;
        r0.<examples.BankAccount: double amount> = $d2;
        $d3 = r0.<examples.BankAccount: double amount>;
        $b1 = $d3 cmpl 1.0E7;
        if $b1 <= 0 goto label0;

        $r3 = new java.lang.StringBuilder;
        $r4 = r0.<examples.BankAccount: java.lang.String name>;
        $r5 = staticinvoke <java.lang.String: java.lang.String valueOf(java.lang.Object)>($r4);
        specialinvoke $r3.<java.lang.StringBuilder: void <init>(java.lang.String)>($r5);
        $r6 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("*");
        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.String toString()>();
        r0.<examples.BankAccount: java.lang.String name> = $r7;

     label0:
        return;
    }


We can see that it's a lot of code for such a simple operation. Moreover the
majority of code is devoted to the modification of the customer's name. Since we
are not interested in tracking such changes, the only contribution of this code
is to increase greatly the state space size. Let's see if we can prune the PDG.

![Bank account PFG](https://raw.github.com/Cecca/jpf-proposal/master/BankAccount.png)

The graph is quite big and complex for such a simple method, however pruning
the nodes that do not influence the relevant state reduce greatly this
complexity, leading to the following Jimple representation

    public void deposit(double)
    {
        examples.BankAccount r0;
        double d0, $d1, $d2;
        byte $b0;

        r0 := @this: examples.BankAccount;
        d0 := @parameter0: double;
        $b0 = d0 cmpl 0.0;
        if $b0 <= 0 goto label0;

        $d1 = r0.<examples.BankAccount: double amount>;
        $d2 = $d1 + d0;
        r0.<examples.BankAccount: double amount> = $d2;

     label0:
        return;
    }

That corresponds to the following Java code

```java
public void deposit(double quantity) {
  if(quantity > 0) {
    amount += quantity;
  }
}
```

The code that changed the name of the customer disappeared from the model
method, leading to a smaller state space for the model checker to handle.


Development methodology
-----------------------

The development methodology I plan to use is Test Driven Development. The
development process will be in 4 steps:

  1. Prototyping: a prototype of the tool will be built, in order to try
     different strategies and to spot hard problems.
  2. Architecture implementation: the general architecture of the tool should be
     implemented before starting the development of the model generation plugins.
  3. Implementation of a random model generator
  4. Implmentation of a model generator based on slicing.


Goals
-----

The goal of this project is to provide a standalone tool and an extension of
OcseGEN to perform model generation for model checkers such as JPF.


About myself
------------

I am a 24 years old Computer Engineering student at University of Padua. 
I'm just about to get my Master degree with a thesis on graph algorithms on top
of the MapReduce framework.

I already worked on an open source project last year, as part of my Google
Summer of Code. The project was about generating and checking model classes for
Java PathFinder. Toghether with my mentor, Nastaran Shafiei, we wrote a paper
about these tools that got published on the ACM Software Engineering notes and
is now available in the ACM digital library.

You can find more about me at my [site](http://www.dei.unipd.it/~ceccarel/).


Availability
------------

As for my availability, I plan to graduate in September. Therefore I will be
working on my thesis throughout the summer. Anyway my last exam is in June, so
during the summer I will have the time to work with commitment to the project.


Previous discussion
-------------------

Having already worked with the JPF people, I already started discussing my idea
with them. The content of this proposal is in large part coming from my
discussions with the mentors.



[Fe87]: http://doi.acm.org/10.1145/24039.24041
  "The program dependence graph and its use in optimization"
